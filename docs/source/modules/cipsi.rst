.. _cipsi:

.. program:: cipsi

.. default-role:: option

=====
cipsi
=====

|CIPSI| algorithm.

The :c:func:`run_stochastic_cipsi` and :c:func:`run_cipsi` subroutines start with a single
determinant, or with the wave function in the |EZFIO| database if
:option:`determinants read_wf` is |true|.

The :c:func:`run_cipsi` subroutine iteratively:

* Selects the most important determinants from the external space and adds them to the
  internal space
* If :option:`determinants s2_eig` is |true|, it adds all the necessary
  determinants to allow the eigenstates of |H| to be eigenstates of |S^2|
* Diagonalizes |H| in the enlarged internal space
* Computes the |PT2| contribution to the energy stochastically :cite:`Garniron_2017.2`
  or deterministically, depending on :option:`perturbation do_pt2`
* Extrapolates the variational energy by fitting
  :math:`E=E_\text{FCI} - \alpha\, E_\text{PT2}`

The difference between :c:func:`run_stochastic_cipsi` and :c:func:`run_cipsi` is that
:c:func:`run_stochastic_cipsi` selects the determinants on the fly with the computation
of the stochastic |PT2| :cite:`Garniron_2017.2`. Hence, it is a semi-stochastic selection. It

* Selects the most important determinants from the external space and adds them to the
  internal space, on the fly with the computation of the PT2 with the stochastic algorithm
  presented in :cite:`Garniron_2017.2`.
* If :option:`determinants s2_eig` is |true|, it adds all the necessary
  determinants to allow the eigenstates of |H| to be eigenstates of |S^2|
* Extrapolates the variational energy by fitting
  :math:`E=E_\text{FCI} - \alpha\, E_\text{PT2}`
* Diagonalizes |H| in the enlarged internal space


The number of selected determinants at each iteration will be such that the
size of the wave function will double at every iteration. If :option:`determinants
s2_eig` is |true|, then the number of selected determinants will be 1.5x the
current number, and then all the additional determinants will be added.

By default, the program will stop when more than one million determinants have
been selected, or when the |PT2| energy is below :math:`10^{-4}`.

The variational and |PT2| energies of the iterations are stored in the
|EZFIO| database, in the :ref:`iterations` module.



Computation of the |PT2| energy
-------------------------------

At each iteration, the |PT2| energy is computed considering the Epstein-Nesbet
zeroth-order Hamiltonian:

.. math::

  E_{\text{PT2}} = \sum_{ \alpha }
    \frac{|\langle \Psi_S | \hat{H} | \alpha \rangle|^2}
         {E - \langle \alpha | \hat{H} | \alpha \rangle}

where the |kalpha| determinants are generated by applying all the single and
double excitation operators to all the determinants of the wave function
:math:`\Psi_G`.

When the hybrid-deterministic/stochastic algorithm is chosen
(default), :math:`Psi_G = \Psi_S = \Psi`, the full wavefunction expanded in the
internal space.
When the deterministic algorithm is chosen (:option:`perturbation do_pt2`
is set to |false|), :math:`Psi_G` is a truncation of |Psi| using
:option:`determinants threshold_generators`, and :math:`Psi_S` is a truncation
of |Psi| using :option:`determinants threshold_selectors`, and re-weighted
by :math:`1/\langle \Psi_s | \Psi_s \rangle`. 

At every iteration, while computing the |PT2|, the variance of the wave
function is also computed:

.. math:: 

  \sigma^2 & = \langle \Psi | \hat{H}^2 | \Psi \rangle -
               \langle  \Psi | \hat{H}   | \Psi \rangle^2 \\
           & = \sum_{i \in \text{FCI}}
               \langle \Psi | \hat{H} | i \rangle 
               \langle i | \hat{H} | \Psi \rangle -
               \langle  \Psi | \hat{H} | \Psi \rangle^2 \\
           & = \sum_{ \alpha }
               \langle |\Psi | \hat{H} | \alpha \rangle|^2.

The expression of the variance is the same as the expression of the |PT2|, with
a denominator of 1. It measures how far the wave function is from the |FCI|
solution. Note that the absence of denominator in the Heat-Bath selected |CI|
method is selection method by minimization of the variance, whereas |CIPSI| is
a selection method by minimization of the energy.


If :option:`perturbation do_pt2` is set to |false|, then the stochastic
|PT2| is not computed, and an approximate value is obtained from the |CIPSI|
selection. The calculation is faster, but the extrapolated |FCI| value is 
less accurate. This way of running the code should be used when the only
goal is to generate a wave function, as for using |CIPSI| wave functions as
trial wave functions of |QMC| calculations for example.


The :command:`PT2` program reads the wave function of the |EZFIO| database
and computes the energy and the |PT2| contribution.


State-averaging
---------------

Extrapolated |FCI| energy
-------------------------

An estimate of the |FCI| energy is computed by extrapolating

.. math::

  E=E_\text{FCI} - \alpha\, E_\text{PT2}

This extrapolation is done for all the requested states, and excitation
energies are printed as energy differences between the extrapolated
energies of the excited states and the extrapolated energy of the ground
state.

The extrapolations are given considering the 2 last points, the 3 last points, ...,
the 7 last points. The extrapolated value should be chosen such that the extrpolated
value is stable with the number of points.




Providers
---------


.. c:var:: initialize_pt2_e0_denominator

    .. code:: text

        logical	:: initialize_pt2_e0_denominator

    File: :file:`energy.irp.f`

    If true, initialize pt2_E0_denominator




.. c:var:: pt2_collector

    .. code:: text

        subroutine pt2_collector(zmq_socket_pull, E, relative_error, pt2, error,  &
          variance, norm, b, N_)

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_cw

    .. code:: text

        double precision, allocatable	:: pt2_w	(N_det_generators)
        double precision, allocatable	:: pt2_cw	(0:N_det_generators)
        double precision	:: pt2_w_t
        double precision	:: pt2_u_0
        integer, allocatable	:: pt2_n_0	(pt2_N_teeth+1)

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_e0_denominator

    .. code:: text

        double precision, allocatable	:: pt2_e0_denominator	(N_states)

    File: :file:`energy.irp.f`

    E0 in the denominator of the PT2




.. c:var:: pt2_f

    .. code:: text

        integer, allocatable	:: pt2_f	(N_det_generators)
        integer	:: pt2_n_tasks_max

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_j

    .. code:: text

        integer, allocatable	:: pt2_j	(N_det_generators)
        integer, allocatable	:: pt2_r	(N_det_generators)

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_mindetinfirstteeth

    .. code:: text

        integer	:: pt2_n_teeth
        integer	:: pt2_mindetinfirstteeth

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_n_0

    .. code:: text

        double precision, allocatable	:: pt2_w	(N_det_generators)
        double precision, allocatable	:: pt2_cw	(0:N_det_generators)
        double precision	:: pt2_w_t
        double precision	:: pt2_u_0
        integer, allocatable	:: pt2_n_0	(pt2_N_teeth+1)

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_n_tasks

    .. code:: text

        integer	:: pt2_n_tasks

    File: :file:`pt2_stoch_routines.irp.f`

    Number of parallel tasks for the Monte Carlo




.. c:var:: pt2_n_tasks_max

    .. code:: text

        integer, allocatable	:: pt2_f	(N_det_generators)
        integer	:: pt2_n_tasks_max

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_n_teeth

    .. code:: text

        integer	:: pt2_n_teeth
        integer	:: pt2_mindetinfirstteeth

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_r

    .. code:: text

        integer, allocatable	:: pt2_j	(N_det_generators)
        integer, allocatable	:: pt2_r	(N_det_generators)

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_stoch_istate

    .. code:: text

        integer	:: pt2_stoch_istate

    File: :file:`pt2_stoch_routines.irp.f`

    State for stochatsic PT2




.. c:var:: pt2_u

    .. code:: text

        double precision, allocatable	:: pt2_u	(N_det_generators)

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_u_0

    .. code:: text

        double precision, allocatable	:: pt2_w	(N_det_generators)
        double precision, allocatable	:: pt2_cw	(0:N_det_generators)
        double precision	:: pt2_w_t
        double precision	:: pt2_u_0
        integer, allocatable	:: pt2_n_0	(pt2_N_teeth+1)

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_w

    .. code:: text

        double precision, allocatable	:: pt2_w	(N_det_generators)
        double precision, allocatable	:: pt2_cw	(0:N_det_generators)
        double precision	:: pt2_w_t
        double precision	:: pt2_u_0
        integer, allocatable	:: pt2_n_0	(pt2_N_teeth+1)

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: pt2_w_t

    .. code:: text

        double precision, allocatable	:: pt2_w	(N_det_generators)
        double precision, allocatable	:: pt2_cw	(0:N_det_generators)
        double precision	:: pt2_w_t
        double precision	:: pt2_u_0
        integer, allocatable	:: pt2_n_0	(pt2_N_teeth+1)

    File: :file:`pt2_stoch_routines.irp.f`

    




.. c:var:: selection_weight

    .. code:: text

        double precision, allocatable	:: selection_weight	(N_states)

    File: :file:`selection.irp.f`

    Weights in the state-average calculation of the density matrix




Subroutines / functions
-----------------------



.. c:function:: add_to_selection_buffer

    .. code:: text

        subroutine add_to_selection_buffer(b, det, val)

    File: :file:`selection_buffer.irp.f`

    





.. c:function:: bitstring_to_list_in_selection

    .. code:: text

        subroutine bitstring_to_list_in_selection( string, list, n_elements, Nint)

    File: :file:`selection.irp.f`

    Gives the inidices(+1) of the bits set to 1 in the bit string





.. c:function:: create_selection_buffer

    .. code:: text

        subroutine create_selection_buffer(N, siz_, res)

    File: :file:`selection_buffer.irp.f`

    





.. c:function:: delete_selection_buffer

    .. code:: text

        subroutine delete_selection_buffer(b)

    File: :file:`selection_buffer.irp.f`

    





.. c:function:: fill_buffer_double

    .. code:: text

        subroutine fill_buffer_double(i_generator, sp, h1, h2, bannedOrb, banned, fock_diag_tmp, E0, pt2, variance, norm, mat, buf)

    File: :file:`selection.irp.f`

    





.. c:function:: get_d0

    .. code:: text

        subroutine get_d0(gen, phasemask, bannedOrb, banned, mat, mask, h, p, sp, coefs)

    File: :file:`selection.irp.f`

    





.. c:function:: get_d1

    .. code:: text

        subroutine get_d1(gen, phasemask, bannedOrb, banned, mat, mask, h, p, sp, coefs)

    File: :file:`selection.irp.f`

    





.. c:function:: get_d2

    .. code:: text

        subroutine get_d2(gen, phasemask, bannedOrb, banned, mat, mask, h, p, sp, coefs)

    File: :file:`selection.irp.f`

    





.. c:function:: get_m0

    .. code:: text

        subroutine get_m0(gen, phasemask, bannedOrb, vect, mask, h, p, sp, coefs)

    File: :file:`selection.irp.f`

    





.. c:function:: get_m1

    .. code:: text

        subroutine get_m1(gen, phasemask, bannedOrb, vect, mask, h, p, sp, coefs)

    File: :file:`selection.irp.f`

    





.. c:function:: get_m2

    .. code:: text

        subroutine get_m2(gen, phasemask, bannedOrb, vect, mask, h, p, sp, coefs)

    File: :file:`selection.irp.f`

    





.. c:function:: get_mask_phase

    .. code:: text

        subroutine get_mask_phase(det1, pm, Nint)

    File: :file:`selection.irp.f`

    





.. c:function:: get_phase_bi

    .. code:: text

        double precision function get_phase_bi(phasemask, s1, s2, h1, p1, h2, p2, Nint)

    File: :file:`selection.irp.f`

    





.. c:function:: make_selection_buffer_s2

    .. code:: text

        subroutine make_selection_buffer_s2(b)

    File: :file:`selection_buffer.irp.f`

    





.. c:function:: merge_selection_buffers

    .. code:: text

        subroutine merge_selection_buffers(b1, b2)

    File: :file:`selection_buffer.irp.f`

    Merges the selection buffers b1 and b2 into b2





.. c:function:: past_d1

    .. code:: text

        subroutine past_d1(bannedOrb, p)

    File: :file:`selection.irp.f`

    





.. c:function:: past_d2

    .. code:: text

        subroutine past_d2(banned, p, sp)

    File: :file:`selection.irp.f`

    





.. c:function:: provide_everything

    .. code:: text

        subroutine provide_everything

    File: :file:`slave_cipsi.irp.f`

    





.. c:function:: pt2_find_sample

    .. code:: text

        integer function pt2_find_sample(v, w)

    File: :file:`pt2_stoch_routines.irp.f`

    





.. c:function:: pt2_find_sample_lr

    .. code:: text

        integer function pt2_find_sample_lr(v, w, l_in, r_in)

    File: :file:`pt2_stoch_routines.irp.f`

    





.. c:function:: pt2_slave_inproc

    .. code:: text

        subroutine pt2_slave_inproc(i)

    File: :file:`pt2_stoch_routines.irp.f`

    





.. c:function:: pull_pt2_results

    .. code:: text

        subroutine pull_pt2_results(zmq_socket_pull, index, pt2, variance, norm, task_id, n_tasks, b)

    File: :file:`run_pt2_slave.irp.f`

    





.. c:function:: pull_selection_results

    .. code:: text

        subroutine pull_selection_results(zmq_socket_pull, pt2, variance, norm, val, det, N, task_id, ntask)

    File: :file:`run_selection_slave.irp.f`

    





.. c:function:: push_pt2_results

    .. code:: text

        subroutine push_pt2_results(zmq_socket_push, index, pt2, variance, norm, b, task_id, n_tasks)

    File: :file:`run_pt2_slave.irp.f`

    





.. c:function:: push_selection_results

    .. code:: text

        subroutine push_selection_results(zmq_socket_push, pt2, variance, norm, b, task_id, ntask)

    File: :file:`run_selection_slave.irp.f`

    





.. c:function:: remove_duplicates_in_selection_buffer

    .. code:: text

        subroutine remove_duplicates_in_selection_buffer(b)

    File: :file:`selection_buffer.irp.f`

    





.. c:function:: run_cipsi

    .. code:: text

        subroutine run_cipsi

    File: :file:`cipsi.irp.f`

    Selected Full Configuration Interaction with deterministic selection and stochastic PT2.





.. c:function:: run_pt2_slave

    .. code:: text

        subroutine run_pt2_slave(thread,iproc,energy)

    File: :file:`run_pt2_slave.irp.f`

    





.. c:function:: run_selection_slave

    .. code:: text

        subroutine run_selection_slave(thread,iproc,energy)

    File: :file:`run_selection_slave.irp.f`

    





.. c:function:: run_slave_cipsi

    .. code:: text

        subroutine run_slave_cipsi

    File: :file:`slave_cipsi.irp.f`

    Helper program for distributed parallelism





.. c:function:: run_slave_main

    .. code:: text

        subroutine run_slave_main

    File: :file:`slave_cipsi.irp.f`

    





.. c:function:: run_stochastic_cipsi

    .. code:: text

        subroutine run_stochastic_cipsi

    File: :file:`stochastic_cipsi.irp.f`

    Selected Full Configuration Interaction with Stochastic selection and PT2.





.. c:function:: select_connected

    .. code:: text

        subroutine select_connected(i_generator,E0,pt2,variance,norm,b,subset,csubset)

    File: :file:`selection.irp.f`

    





.. c:function:: select_singles_and_doubles

    .. code:: text

        subroutine select_singles_and_doubles(i_generator,hole_mask,particle_mask,fock_diag_tmp,E0,pt2,variance,norm,buf,subset,csubset)

    File: :file:`selection.irp.f`

    WARNING /!\ : It is assumed that the generators and selectors are psi_det_sorted





.. c:function:: selection_collector

    .. code:: text

        subroutine selection_collector(zmq_socket_pull, b, N, pt2, variance, norm)

    File: :file:`zmq_selection.irp.f`

    





.. c:function:: selection_slave_inproc

    .. code:: text

        subroutine selection_slave_inproc(i)

    File: :file:`zmq_selection.irp.f`

    





.. c:function:: sort_selection_buffer

    .. code:: text

        subroutine sort_selection_buffer(b)

    File: :file:`selection_buffer.irp.f`

    





.. c:function:: splash_pq

    .. code:: text

        subroutine splash_pq(mask, sp, det, i_gen, N_sel, bannedOrb, banned, mat, interesting)

    File: :file:`selection.irp.f`

    





.. c:function:: spot_isinwf

    .. code:: text

        subroutine spot_isinwf(mask, det, i_gen, N, banned, fullMatch, interesting)

    File: :file:`selection.irp.f`

    





.. c:function:: testteethbuilding

    .. code:: text

        logical function testTeethBuilding(minF, N)

    File: :file:`pt2_stoch_routines.irp.f`

    





.. c:function:: zmq_pt2

    .. code:: text

        subroutine ZMQ_pt2(E, pt2,relative_error, error, variance, norm, N_in)

    File: :file:`pt2_stoch_routines.irp.f`

    





.. c:function:: zmq_selection

    .. code:: text

        subroutine ZMQ_selection(N_in, pt2, variance, norm)

    File: :file:`zmq_selection.irp.f`

    


